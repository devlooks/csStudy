### 1. 클라이언트와 서버의 차이

- 클라이언트 : 접속 동작 수행

- 서버 : 기다리는 형태, 다수의 클라이언트 PC와 대화한다는 차이점, 

- Socket 라이브러리의 프로그램 부품이 다름

- 서버와 클라이언트 애플리케이션과 구조가 다르다.

### 2. 서버 애플리케이션의 구조 

- 클라이언트가 접속 할 떄마다 새로 서버 프로그램을 작동하여
  서버 애플리케이션이 클라이언트와 1:1로 대화하는 방법을 선택하는 것이 일반적

- 서버 OS는 멀티태스크 또는 멀티스레드라는 기능에 의해 다수 프로그램을 동시에 함꼐 작동
  단점 : 클라이언트가 접속했을떄 새로 프로그램을 가동하는 부분에서 다소 시간이 걸리고,
         응답 시간이 추가로 소요된다는 것
         
- 클라이언트와 대화하는 몇개의 부분을 작동시키고 클라이언트가 접속했을떄, 
  클라이언트의 상대를 처리하지 않는 비어있는것을 찾아 여기에 접속한 소켓을 건네주어
  클라이언트와의 대화를 계속 하는 방법이 있음
  
### 3. 서버측의 소켓과 포트 번호

- 클라이언트와 서버의 차이점
  
  1. 접속하는 측이 클라이언트, 접속을 기다리는 측이 서버
  
  2. Socket 라이브러리를 호출하는 부분에서의 차이점
    - 클라이언트 소켓 호출 흐름
      1. 소켓만듬
      2. 서버측의 소켓과 파이프로 연결
      3. 데이터를 송수신 한다
      4. 파이프를 분리 소켓을 말소한다.

    - 서버측 소켓 호출 흐름
      1. 소켓을 만든다
      2-1. 소켓을 접속 대기상태로 ㅁ나든다
      2-2. 접속을 접수합니다.
      3. 데이터를 송수신합니다
      4. 파이프를 분리, 소켓을 말소합니다,

- 서버 측 소켓 동작 
  1. socket 호출 : 소켓을 만듬
  2. bind 호출 : 소켓에 포트 번호 기록
      - 클라이언트 측에서 접속동작을 실행 할때, 서버측의 소켓에 할당한 포트 지정 
        -> 포트번호(구체적인건 규칙에 의해 정해져있음, 80, 443)
  4. listen 호출 : 소켓에 접속을 기다리는 상태라는 제어정보 기록
  5. accept 호출 : 서버측은 패킷의 도착을 기다리는 상태, 애플리케이션은 쉬는 상태
    - 패킷 도착시 응답 패킷을 반송, 접속 접수 동작을 실행한다.
    - 접속 대기의 소켓을 복사(같은 포트번호 할당), 새로운 소켓을 만듬
    - 접속 상대의 정보를 비롯한 제어 정보를 새 소켓에 기록 ( 해당 새소켓으로 서버와 클라이언트가 대화)
  6. accept가 끝나면 접속 대기 동작 종료 -> 서버와 클라이언트가 대화하는 부분 기동

- 원래 있던 접속 동작시 사용된 소켓은 접수 대기 상태로 계속 존재 하며, accept가 재 호출시, 접속 접수 동작을 수행한다.

- 기존 접속 대기 소켓을 복사하는 이유는, 접속이 끝난후 말소가 되어 없어지기 때문.

- 새소켓 생성시, 기존 소켓과 동일한 포트 번호를 할당하게 되는데, 이는 서버측에선 포트번호로 소켓을 구분할수 없게한다.  
  하지만 클라이언트의 소켓은 모두 다른 포트번호를 할당 하므로, 클라이언트 측의 포트 번호에 따라 소켓을 지정 가능하다.
  즉, (클라이언트 ip 주소 + 클라이언트에서 할당한 포트번호)와 서버측의 소켓의 동일한 포트번호와 수신처ip(통신 클라이언트ip주소)를 가진 포트번호를 비교
  하여, 서버측에서 소켓을 선택한다.
  
- 디크스립터는 접속이 수행되지 않는(접속대기상태) 소켓을 서버측에서 선택하는데 도움을 준다.


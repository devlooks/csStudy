## tomcat7부팅 과정중 bootstrap 객체의 init 메서드의 핵심.

1. 기본 추론 : HTTP 요청을 받기 위해 소켓을 열고, 서블릿을 초기화 하며  
   스레드를 관리하는 등 웹 서비스를 동작하게 하는 기능이 있으리라 짐작 할 수 있음.

3. 중요한것을 initClassLoader 메서드  
   해당 클래스 로더는 세 개의 클래스 로더 생성한다.  
   common, server, shared 각 클래스 로더를 의미하며 server와 shared는 common를 부모로 가진다.

4. 각 클래스 로더는 catalina.properties 파일에 정의된 디렉터리의 jar파일을 읽는다.  
   파일안에 포함된 클래스 로딩.
   catalina.properties에 있는 common 클래스로더만 설치 디렉터리 아래 lib 디렉터리로 지정됨.
   shared, server 클래스 로더는 위치가 지정되어 있지 않다.  
   즉, 설정을 변경 하지 않으면 shared, server 클래스 로더에 아무런 영향은 없다.

## 서블릿 컨테이너가 사용자가 작성한 서블릿을 어떻게 호출하는가?

1. 서블릿 컨테이너는 서블싱 포함된 웹 어플리케이션을 동작을 위해  
   전용 클래스 로더를 추가로 생성  
   
2. 웹 어플리케이션을 위한 클래스로더는 서블릿 명세에 미리 약속된 특정 위치  
   ex)WEB-INF/lib, WEB-INF/classes 
   에 있는 jar, class 파일을 로딩한다.

3. 모든 서블릿은 javax.servlet.Servlet 인터페이스를 구현하므로 서블릿 컨테이너는
   사용자가 작성한 다양한 형태의 서블릿을 Servlet.service 메서드로 호출 할수 있음.

### 해당 과정의 이유

1. 톰캣과 같은 서블릿 컨테이너는 위와 같은 전략, (리소스 위치, 호출할 메서드 미리 정함) 사용.  
   왜냐하면, 라이브러리에 포함된 모든 jar파일을 일일이 나열하면 관리가 힘듬
   컨테이너 추가하고 싶은 라이브러리 있을때마다 수정하기 힘듬

2. 그래서 톰캣은 jvm시작 할수 있는 최소한의 클래스만 bin 아래 bootstrap.jar 파일에 모으고  
   기동 스크립트 내에서는 jar파일을 클래스 패스로 설정한다. 
 
3. 구동시, 실제 서블릿 컨테이너 역할을 할 클래스로더를 새로 생성하고, 특정 디렉터리 아래 있는  
   모든 jar 파일을 등록 하게 함으로서 사용자가 서블릿 컨테이너에 추가 하고 싶은 lib 디렉터리 아래  
   추가하면 별다른 설정 없이도, 클래스패스 추가되도록 한다.

## 생명주기 관리

1. config 파일(xml)에 지정된 객체들을 시동시, 자동으로 생성, 유지, 관리, 소멸등의 생명주기를 관리.  
   서버를 재시동 하지 않고 기능 변경 하는 방법 제공

2. 서블릿 생명주기 관리와 비슷 -> 서블릿 인터페이스 역할을 하는 Lifecycle 인터페이스 존재
   (서블릿 인터페이스에 init, destory 메서드가 있어, 해당 서블릿이 초기화 되거나 소멸시,
   서블릿 컨테이너가 해당 메서드를 호출했다는 사실을 기억.)
   
3. 서블릿은 http요청이 들어올떄 service 메서드 호출에 반해, Lifecycle 인터페이스는 관리자가 
   능동적으로 활성화되거나 정지 할 수 있음. (start/stop 메서드 존재)
   
4. 즉, 사용자가 설정 파일에 정의된 각 XML 엘리먼트는 Digester(xml파일 객체 매핑 라이블러리)에 의해  
   서버 객체로 변경돼 로딩, 이런 객체는 Lifecycle 인터페이스를 구현했으므로 프로그래밍 적으로 초기화, 시작, 종료, 소멸등을 
   컨트롤 할수 있다는 것.
   
## Shutdown Hook

1. 톰캣 서블릿 컨테이너를 종료하려면 bin/shutdown 스크립트를 사용
   해당 스크립트가 호출되면 Lifecycle 인터페이스를 구현한 객체의 stop 메서드와 destory 메서드를 차례로 호출
   개별 객체 수행 작업 종료, 리소스 반환한다.
   
2. 하지만, 매번 Control-C로 강제종료하는 사용자가 있을것이므로,
   **Shutdown Hook**를 추가, 최소한의 리소스 반환 처리를 도모
   
## System.out과 catalina.out

1. System.out이 동기적이여야하는 이유 : 비동기적일시, System.out에 문자열 출력시,  
   두개 이상의 스레드에서 동시에 System.out에 문자열 출력시, 섞일 가능성이 있음

2. 위의 이유로, catalina.out도 동기적으로 구현되어있음.
   

# 병렬처리

## stop/suspend 메서드가 deprecated가 된이유

1. stop 사용하여 정지시, 스레드의 뮤택스가 전부 해제 됨.  
   그러므로 **상태 변경이 완료 되지 전의 형상에 접근 할수 있게됨**
   그 상태에서 변경이 발생한다면, 원인을 매우 찾기 어려운 버그 발생
2. suspend 사용하여 정지시, 리소스에 접근하려는 스레드는 suspend된 스레드가  
   스스로 동작을 재개해 뮤택스를 풀기 전까지 기약없이 대기 하는 문제 발생
   (정지된 쓰레드가 스스로 정지를 풀어야 동작하게 되는현상)

**뮤텍스 : 상호 배제 잠금**

## wait/notify 메서드의 사용

  1. 톰캣 4.x 에선, 스레드 풀은 각 스레드에 lock 걸린 상태로 객체를 생성
  2. 해당 객체에 대해 wait 메서드 호출 스레드 대기 상태로 변경
  3. 요청이 들어오면 스레드를 대기리스트에서 뺴서, 서블릿 실행에 필요한 정보를 전달
  4. 스레드 notify로 활성화 상태로 변경
  5. 이때 notify는 wait메서드 이후로 진행 재개
  6. 활성화 종료 되면 다시, 쓰레드 대기 리스트로 재진입

-> **내부 락을 사용해 개별적으로 대기 구현하는 방법 -> 가장 직관적 스레드 풀링 구현**

-> **Concurrent queue를 통한 스레드 풀링 구현 가능  
  쓰레드를 Concurrent queue에 넣고, queue.take메서드를 사용 스레드 동작(비교적 단순 구조)** 
  
  
## 스레드 풀의 구성요소 - jetty 6.x

- 단순 리스트에 쓰레드를 저장 하여,  
  하나씩 동작 시키는 것에 대한 문제점 세가지
  **쓰레드풀 구현에 대한 문제점 세가지**

1. 수행이 완료된 쓰레드는 종료되어 버려진다.  
  -> 쓰레드는 재사용이 가능 해야한다.
2. 쓰레드가 가지고 있는 job이 없더라도 계속 작동하고 된다. (busy wait를 막아야 한다)
  -> 자신이 처리할 job이 없는경우 wait 메서드 사용, 대기 상태로 들어가야한다.
3. 병렬 실행 하는 특정 처리를 Thread 객체에 어떻게 전달 하는냐는 것.  
  -> 인터페이스를 통한 해결
  
## java.util.concurrent 패키지

- java.util.concurrent 패키지에는 ThreadPoolExecutor라는 이름의 범용쓰레드 풀 구현제 추가.
- ThreadPoolExecutor라는 클래스를 통해 직렬 처리 및, 병렬처리 가능 
- BlockingQueue의 성질에 따라 미묘한 3가지 수행 방식 있음
  1. SynchronousQueue는 수행 요청이 들어오면 요청을 쌓아두지 않고 즉시 준비된 스레드로 처리
    -> 처리되는 속도보다 요청이 들어오는 속도가 빠르면 스레드 수가 비정상적으로 증가
  2. corePoolSize수만큼 스레드를 사용해 동작 해당 수보다 많은 요청이 들어오면  
    스레드의 수를 늘리는 대신, 요청을 큐에 쌓아놓고 처리
    -> 처리속도 보다 요청 들어오는 속도가 빠를경우, 큐의 크기가 비정상적으로 커지는 문제 발생
  3. ArrayBlockingQueue는 사용 미리 정해진 큐 사이즈를 넘는 요청을 모두 버림.
    -> 큐 이상의 요청갯수가 들어오면 나머지 요청은 버려짐
    
 **따라서 세타입은 서로 기능 및 안정성에 대한 트레이드 오프 존재, 상황에 맞게 사용해야함**
 
 ## 적정 병렬 진행수
 
 - 서블릿을 처리 하기 위해, 스레드 풀이 내부적 유지하는 워커 스레드의 숫자 지정 가능
 - 이 숫자에 따라 서블릿 컨테이너의 처리량이 크게 영향을 받음
 
 ### 최적의 스레드 개수는 CPU 코어 마다 하나의 스레드가 할당되게 설정하는 것이 최적인가?
 - 스레드는 CPU연산 능력에만 의존 하지 않음
 - 병렬화 가능 하지 않는 영역이 존재함.
   - CPU 코어를 최대한 동작 시킬 방법이 있다는 가정하에 가능
 - 병렬처리를로 인한 추가 제약조건
   - 메모리에 저장된 값에 대한 개별 접근 필요(접근 성능).
   - 서블릿 컨테이너의 최대 처리량에 대한 제약조건은 CPU처리량이 아니라 I/O 처리량이라는것을 아고 있어야함
 - 컨텍스트 스위칭
   - 스레드 수가 많아지면 성능 저하의 원인
   - 시분할 기법을 사용, cpu사용후, 다른 프로세스, 스레드에 사용 양보-> 대기하다 차례가 오면 수행
   - 위의 처럼, 양보시점에 결과물을 문맥에 저장 해놨다, 다시 자신의 차례가 오면 저장 했던 정보를
   - 문맥을 되돌리는 컨텍스트 스위칭 발생
   **스레드의 수가 많아지면 cpu 점유에 대한 경쟁조건 심화, 컨텍스트 스위칭이 그만큼 더 자주 발생**
   -> 컨텍스트 스위칭 발생을 억제 하도록 하여 성능 개선 시켜야함.(스레드 개수는 특정한 한계가 있음)
   
**결과적으로 사이트의 서블릿 특성에 따라 좌우, 설정값을 적절히 변경해 가며 최적의 값을 찾아야함**
 
